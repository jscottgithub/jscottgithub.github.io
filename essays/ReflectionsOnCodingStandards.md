---
layout: essay
type: essay
title: "Reflections on Coding Standards"
# All dates must be YYYY-MM-DD format!
date: 2024-09-26
published: true
labels:
  - Typescript
  - Reflection
  - Assignment
---

<img width="200px" class="rounded float-start pe-4" src="../img/jumpingthruhoops.jpg">


*Reflections on Coding Standards*

## Much ado about time management

In this day and age, people feel like they have less time than ever. Why is that? A multitude of reasons, among them a vast wealth of entertainment, daily chores: tasks related to the constant upkeep of life, obligations to jobs or special interest groups, and ultimately (if applicable), schoolwork. 

It's tempting to rush through one's list of tasks for the day, or even neglect responsibilities in order to triage one's time for the sake of 'getting to the good part'; and of course who in their right mind wouldn't understand such preference? Naturally the time already allocated to the tedium of life is something to be optimized for a minimum, so of course anyone might shy away from *extending* the amount of time one spends on chores!

## You want me to do *what*?

The magic of how the nature of coding functions natively disregards extended gaps of spaces and newlines, as IDEs and compilers alike know to do their own version of 'getting to the good part'. As such a programmer may rest easy knowing that however many times they nervously tap the spacebar or 'enter', the computer will understand. Heck, some IDEs even innately provide limited autocorrect functionality, or at least hints toward expected syntax. So why the need for coding standards?

## How did we get here?

When generations of quality-of-life improvements and program optimizations have set the standard for ease-of-writing, those who have become utterly reliant on autocorrect (Or Clippy, if ya' *OLD*) to write interpersonal communiques have primed themselves to stumble. Whereas previously a student may have trained themself to obsessively comb through their written text for errors, pinky posted above the backspace, today the bulk of corrections are performed autonomously without so much as the need to glance upwards (or even at the screen!). Sure, sometimes disambiguation between potential intended words must be selected between by the user, but as predictive technology improves that figure of time spent correcting oneself may slowly inch its way toward 0. 

## Time to grow. AKA: *Why* we're here.

As forgiving as the 'Machine Spirit' may be, we are still but acolytes before the pedestals of knowledge that we hope to imbibe, mere petitioners before the fonts of power which we seek to harness. Through abiding by standards we move code into *standardized* formats, not for the computers but the humans who guide our growth. As elaborated upon by University of Hawaii's *Ravi Narayan*, the sheer number of students who submit work for evaluation merits the need for organization. The interchangability of code and the ease with which a group of learners might arrive at different implementations, highlights the importance of optimizing for readability. 

I pride myself on being able to consume and comprehend a given body of code, even if it may be slow going and takes me an hour or two, it's important to know how things work. That said, I cannot expect an instructor or even a TA to spare time for such ponderous analysis. These standards are to help the teachers, so that they may help us learn-- It does nobody any favors to needlessly slow things down. 

While I have found ESLint to be tedious in learning, now that I'm comfortable with its use I have found it to be relatively simple a muse to appease. More frustrating are the syntax errors, which ESLint isn't meant for, but there's always the option to consult educators, or failing that, chatGPT. I was already well familiar with VSCode, but the inclusion of ESLint served to widen the perceived versatility of the IDE. All in all, coding standards can be humbug, but the end purpose of timely learning is well served by the means of managing minutia.
